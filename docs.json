[{"name":"CodeGenerator","comment":" This module let's you define (or change) type-oriented principled code generators.\n\nBy type oriented we mean generators that are driven by a type definition provided by the user.\n\nBy principled we mean that the generated code will for the foremost follow compositional patterns to be able to express (almost) any type.\n\n@docs CodeGenerator, define, amend\n\n\n### Defining code generators\n\n@docs Definition, ifUserHasDependency\n\n\n### Primitives\n\n@docs int, float, string, char, list, dict, maybe\n\n\n### Tuples\n\n@docs unit, tuple, triple\n\n\n### Combining values\n\n@docs succeed, map, mapN, pipeline, combiner\n\n\n### Dealing with custom types\n\n@docs customType, lambdaBreaker\n\n\n### Going crazy\n\n@docs custom\n\n","unions":[{"name":"Definition","comment":" Definitions are a way to to generate and compose small snippets of code to handle specific situations that might occur in an Elm type.\nFundamentally you can think of all the definitions put together as forming a rather sophisticated function `ResolvedType -> Expression`, however this library will handle a large number of gotcha's for you, so it's more convenient to define the function piece-meal.\n","args":[],"cases":[]}],"aliases":[{"name":"CodeGenerator","comment":" Represents a code generator configuration.\n","args":[],"type":"Internal.CodeGenerator.CodeGenerator"}],"values":[{"name":"amend","comment":" Don't like how one of the built-in or third-party generators generates code?\nCode generation can be a little opinionated after all. With this function you can override pieces of another code\ngenerators behavior. You'll need to find out the target generators ID, then you can pass in the new definitions that will\ntake precedence over the existing ones.\n","type":"String.String -> List.List CodeGenerator.Definition -> CodeGenerator.CodeGenerator"},{"name":"char","comment":" Handle a `Char` type.\n","type":"Elm.Syntax.Expression.Expression -> CodeGenerator.Definition"},{"name":"combiner","comment":" If map, mapN, succeed, pipeline don't work for you, this is a more custom way to combine these.\n\nThe arguments that the function you pass will recieve are:\n\n1.  Information about the type being constructed (e.g. `Foo Int`).\n2.  An expression representing a function that creates the type in question (e.g. `makeFoo : Int -> Foo`).\n3.  A list of expressions that have already been generated (e.g. `[ Decode.int ]`)\n\n","type":"(ResolvedType.ResolvedType -> Elm.Syntax.Expression.Expression -> List.List Elm.Syntax.Expression.Expression -> Maybe.Maybe Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"custom","comment":" This allows you complete freedom in generating expressions, however it also doesn't give you much help.\n\nThe recommendation here is to use the normal definitions and only use this for exceptional cases.\n\n","type":"(ResolvedType.ResolvedType -> Maybe.Maybe Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"customType","comment":" Deal with custom types. You will get a list of `( constructorName, expressionThatGeneratesTheTypeWithThatConstructor )`.\n\nThe challenge is to work out which of the branches should be chosen. You can solve that with a `andThen`, or the library might have a different mechanism for disjunctions.\n\n","type":"(List.List ( ResolvedType.Reference, List.List ResolvedType.ResolvedType ) -> List.List ( String.String, Elm.Syntax.Expression.Expression ) -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"define","comment":" Create a code generator. This requires the following pieces:\n\n  - a unique id. This id can be used to extend the generator later.\n  - a dependency name which specifies what this generator deals with. This generator will only be active if the user has the dependency installed.\n  - a search function that is used to figure out which type the function should work on.\n  - a function that generates names if the generator needs to make an auxiliary definition\n  - a list of Definitions that determine how code is actually generated. Note that later definitions will override previous ones.\n\nThe search function should return `Nothing` if the type annotation is not of interest. It should return a `Just childTypeAnnotation` if this generator wants to handle this type.\n\nFor example, if we were to build a generator for `Random.Generator someType` values (i.e. `Typed (Node _ ( [ \"Random\" ], \"Generator\" )) [ Node _ someType ]` in elm-syntax parlance), then this search function should return `Just someType`:\n\n    searchFunction : TypeAnnotation -> Maybe TypeAnnotation\n    searchFunction annotation =\n        case annotation of\n            Typed (Node _ ( [ \"Random\" ], \"Generator\" )) [ Node _ child ] ->\n                Just child\n\n            _ ->\n                Nothing\n\nAlso note that you will always get module names normalized, i.e. you will always see `( [ \"Random\" ], \"Generator\" )` even if the user has `import Random as Foo exposing (Generator)`, so no need to worry about that.\n\n","type":"String.String -> String.String -> TypePattern.TypePattern -> (String.String -> String.String) -> List.List CodeGenerator.Definition -> CodeGenerator.CodeGenerator"},{"name":"dict","comment":" Handle a `Dict`.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"float","comment":" Handle a `Float` type.\n","type":"Elm.Syntax.Expression.Expression -> CodeGenerator.Definition"},{"name":"ifUserHasDependency","comment":" Apply this definition conditionally if the user has this specific dependency installed (can be chained). Intended for things like json-pipeline or random-extra.\n","type":"String.String -> CodeGenerator.Definition -> CodeGenerator.Definition"},{"name":"int","comment":" Handle an `Int` type.\n","type":"Elm.Syntax.Expression.Expression -> CodeGenerator.Definition"},{"name":"lambdaBreaker","comment":" Elm only allows recursive definitions if there is a lambda somewhere in the chain. For instance:\n\n    naiveListDecoder : Decoder (List Int)\n    naiveListDecoder =\n        Decode.oneOf\n            [ Decode.map2 (::) (Decode.index 0 Decode.int) (Decode.index 1 naiveListDecoder)\n            , Decode.null []\n            ]\n\nwould fail to compile, as this would crash immediately on calling the program with an infinite loop. Incidentally this would compile:\n\n    naiveListDecoder2 : Decoder a -> Decoder (List a)\n    naiveListDecoder2 childDecoder =\n        Decode.oneOf\n            [ Decode.map2 (::) (Decode.index 0 childDecoder) (Decode.index 1 (naiveListDecoder2 childDecoder))\n            , Decode.null []\n            ]\n\nBut the code would fail at runtime with a Maximum Call Stack Exceeded exception. However, this version would work fine:\n\n    smartListDecoder : Decoder (List Int)\n    smartListDecoder =\n        Decode.field \"length\" Decode.int\n            |> Decode.andThen\n                (\\l ->\n                    case l of\n                        0 ->\n                            Decode.succeed []\n\n                        2 ->\n                            Decode.map2 (::) (Decode.index 0 Decode.int) (Decode.index 1 smartListDecoder)\n\n                        _ ->\n                            Decode.fail \"Unexpected list length\"\n                )\n\nThe reason being the lambda, that is only evaluated when a preceding step succeeds, hence there will be no infinite evaluation.\n\nOf course, most libraries have a solution to this problem, typically called `lazy`, which we could use here:\n\n    smartListDecoder2 : Decoder (List Int)\n    smartListDecoder2 =\n        Decode.oneOf\n            [ Decode.map2 (::) (Decode.index 0 Decode.int) (Decode.index 1 (Decode.lazy (\\() -> smartListDecoder2))\n            , Decode.null []\n            ]\n\nHowever, if there is no `lazy` function, it can be implemented in terms of `andThen` and `succeed`:\n\n    lazy fn =\n        andThen fn (succeed ())\n\nWe call this `lazy` function a `lambdaBreaker`, since it's purpose it to break recursion with a lambda. Implementing it will enable the code generator to deal with recursive types.\n\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"list","comment":" Handle a `List a` type. You will be given code that handles the `a` subtype.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"map","comment":" Transform a value inside a type. You will be handed the arguments.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"mapN","comment":" A convenient way to specify `map2`, `map3`, `map4`, etc.\n\nThe first argument specifies up to what number of arguments you want to specify the `mapN`.\n\nThe first argument in the callback is the standard name, so for 3 arguments you will get `\"map3\"`.\n\n","type":"Basics.Int -> (String.String -> Elm.Syntax.Expression.Expression -> List.List Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"maybe","comment":" Handle a `Maybe a` type. You will be given code that handles the `a` subtype.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"pipeline","comment":" Deal with any number of arguments using applicative style. The first argument is like for succeed, the second is a partially applied `andMap`.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> (Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"string","comment":" Handle a `String` type.\n","type":"Elm.Syntax.Expression.Expression -> CodeGenerator.Definition"},{"name":"succeed","comment":" Wrap a value in the type. This is called different things in different libraries (i.e. `List.singleton`, `Random.constant`, etc.)\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"triple","comment":" Deals with 3-tuples (i.e. triples). No need to implement if you have `map3`, as it will automatically be used.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"tuple","comment":" Deals with 2-tuples (i.e. pairs). No need to implement if you have `map2`, as it will automatically be used.\n","type":"(Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression -> Elm.Syntax.Expression.Expression) -> CodeGenerator.Definition"},{"name":"unit","comment":" Handle the unit `()` type.\n","type":"Elm.Syntax.Expression.Expression -> CodeGenerator.Definition"}],"binops":[]},{"name":"CodeGenerator.Test","comment":" Testing code generators can be tricky, but very rewarding as it makes developing CodeGenerators much easier.\n\n@docs codeGenTest, codeGenTestFailsWith, fakeDependency\n\n","unions":[],"aliases":[],"values":[{"name":"codeGenTest","comment":" Tests that a single `Debug.todo` gets replaced with a particular piece of code.\n\n    codeGenTest \"Generates a generator for a int\"\n        [ fakeDependency \"elm/random\" ]\n        [ elmRandomCodeGeneratorUnderTest ]\n        [ \"\"\"module A exposing (..)\n    import Random\n\n    generator : Random.Generator Int\n    generator =\n        Debug.todo \"\"\n    \"\"\" ]\n        \"\"\"module A exposing (..)\n    import Random\n\n    generator : Random.Generator Int\n    generator =\n        Random.int Random.minInt Random.maxInt\n    \"\"\"\n\nThe arguments are:\n\n1.  Description (i.e. what you would normally pass to `Test.test`)\n2.  A list of dependencies. Note that this rule will only activate code generators based on dependencies in the user's project. This allows you to control which dependencies are present.\n3.  A list of code generators. Typically this will be the code generator under test, but can also be used to test interactions between multiple.\n4.  A list of code modules that form the project the rule is being run on. Exactly one of these must have a single top level `Debug.todo` that the test is trying to replace.\n5.  The expected source code of the module containing the `Debug.todo` after running the code generator.\n\n","type":"String.String -> List.List Review.Project.Dependency.Dependency -> List.List CodeGenerator.CodeGenerator -> List.List String.String -> String.String -> Test.Test"},{"name":"codeGenTestFailsWith","comment":" Like `codeGenTest`, but expects the code generator to not be able to generate code. The final string is the expected error message.\n","type":"String.String -> List.List Review.Project.Dependency.Dependency -> List.List CodeGenerator.CodeGenerator -> List.List String.String -> String.String -> Test.Test"},{"name":"fakeDependency","comment":" Creates a fake elm review dependency type. This should only be used with the other helpers in this module, as the information inside the returned type is mostly rubbish.\n","type":"String.String -> Review.Project.Dependency.Dependency"}],"binops":[]},{"name":"NoDebug.Log","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Forbid the use of [`Debug.log`](https://package.elm-lang.org/packages/elm/core/latest/Debug) before it goes into production or fails in the CI.\n\nðŸ”§ Running with `--fix` will automatically remove all the reported errors.\n\n`Debug.log` is useful to debug your code, but should not be pushed to production.\n\n    config =\n        [ NoDebug.Log.rule\n        ]\n\n\n## Fail\n\n    if Debug.log \"condition\" condition then\n        a\n\n    else\n        b\n\n\n## Success\n\n    if condition then\n        a\n\n    else\n        b\n\n\n# When (not) to use this rule\n\nYou should use this rule if you're developing a package meant to be published,\nor an application that is put into production, and wish to know about the use of\n[`Debug.log`](https://package.elm-lang.org/packages/elm/core/latest/Debug#log)\nmodule before committing your changes.\n\nYou should not use this rule if you are developing an application that is not\nput into production, and you do not care about having stray debug logs, and you\ndo not ship to production.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-debug/example --rules NoDebug.Log\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoDebug.TodoOrToString","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Forbid the use of [`Debug.todo`] and [`Debug.toString`].\n\n    config =\n        [ NoDebug.TodoOrToString.rule []\n        ]\n\nThe reason why there is a is separate rule for handling [`Debug.log`] and one for\nhandling [`Debug.todo`] and [`Debug.toString`], is because these two functions\nare reasonable and useful to have in tests.\n\nYou can for instance create test data without having to handle the error case\neverywhere. If you do enter the error case in the following example, then tests\nwill fail.\n\n    testEmail : Email\n    testEmail =\n        case Email.fromString \"some.email@domain.com\" of\n            Just email ->\n                email\n\n            Nothing ->\n                Debug.todo \"Supplied an invalid email in tests\"\n\nIf you want to allow these functions in tests but not in production code, you\ncan configure the rule like this.\n\nimport Review.Rule as Rule exposing (Rule)\n\n    config =\n        [ NoDebug.TodoOrToString.rule []\n            |> Rule.ignoreErrorsForDirectories [ \"tests/\" ]\n        ]\n\n\n## Fail\n\n    _ =\n        if condition then\n            a\n\n        else\n            Debug.todo \"\"\n\n    _ =\n        Debug.toString data\n\n\n## Success\n\n    if condition then\n        a\n\n    else\n        b\n\nðŸ”§ Running with `--fix` will automatically generate code to replace some `Debug.todo` uses.\n\nIn particular it will generate code when `Debug.todo` is used in a top-level definition with an explicit\ntype annotation, like so:\n\n     someFunction : Decoder SomeType\n     someFunction =\n            Debug.todo \"\"\n\nThere is an ever-expanding list of type signatures that this rule supports, however, it is relatively straightforward to\nadd your own.  See [`CodeGenerator`](CodeGenerator) for details.\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template MartinSStewart/elm-review-todo-it-for-me/example --rules NoDebug.TodoOrToString\n```\n\n[`Debug.log`]: https://package.elm-lang.org/packages/elm/core/latest/Debug#log\n[`Debug.todo`]: https://package.elm-lang.org/packages/elm/core/latest/Debug#todo\n[`Debug.toString`]: https://package.elm-lang.org/packages/elm/core/latest/Debug#toString\n\n","type":"List.List Internal.CodeGenerator.CodeGenerator -> Review.Rule.Rule"}],"binops":[]},{"name":"ResolvedType","comment":" This module is at the heart of the code generation process.\nThis library works by gathering all the information necessary to build this type,\nthen the code generator's job is to translate this type into an AST.\n\n@docs ResolvedType, Reference\n\n","unions":[{"name":"ResolvedType","comment":" Represents an Elm type that has been fully resolved:\n\n  - all references are now in absolute module format\n  - type variable applications have been applied\n  - custom type and type alias information has been added\n\nThe constructors are:\n\n  - `GenericType \"foo\" ref` represents an unfilled type variable `foo`\n  - `Opaque ref vars` represents a custom type (or built in type)\n  - `Function args return` represents a function type\n  - `TypeAliasRecord ref args definition` represents a record where we have a type alias (and therefore a constructor) available\n  - `AnonymouseRecord extensionVar definition` represents an anonymous record\n  - `CustomType ref args [(constructorRef, arguments)]` represents a reference to an exposed (or accessible) custom type\n  - `Tuple args` represents a tuple.\n\nLet's look at some simple examples and see how they would be represented:\n\n    Int --> Opaque { modulePath = [\"Basics\"], name = \"Int\" } []\n\n    List Int --> Opaque { modulePath = [\"Basics\"], name = \"List\" } [Opaque { modulePath = [\"Basics\"], name = \"Int\" } []]\n\n    List a --> Opaque { modulePath = [\"Basics\"], name = \"List\" } [ GenericType \"a\" Nothing ]\n\n    Int -> String  --> Function [ Opaque { modulePath = [\"Basics\"], name = \"Int\" } [] ] Opaque { modulePath = [\"String\"], name = \"String\" } []\n\n    { foo : Int } --> AnonymousRecord Nothing [ ( \"foo\",  Opaque { modulePath = [\"Basics\"], name = \"Int\" } [] ) ]\n\n    { x | foo : Int } --> AnonymousRecord (Just \"x\") [ ( \"foo\",  Opaque { modulePath = [\"Basics\"], name = \"Int\" } [] ) ]\n\n    () -> Tuple []\n\n    ( Int, String ) --> Tuple [ Opaque { modulePath = [\"Basics\"], name = \"Int\" } [], Opaque { modulePath = [\"String\"], name = \"String\" } [] ]\n\nNow for some more complex examples:\n\n    type Foo a =\n        Bar a\n\n    Foo a --> CustomType { modulePath = [], name = \"Foo\" } [ \"a\" ] [ ( { modulePath = [], name = \"Bar\" }, [ GenericType \"a\" Nothing ] ) ]\n\n    Foo Int --> CustomType { modulePath = [], name = \"Foo\" } [ \"a\" ] [ ( { modulePath = [], name = \"Bar\" }, [ GenericType \"a\" (Just (Opaque { modulePath = [\"Basics\"], name = \"Int\" } [] ))] ) ]\n\nNote how in `Foo Int` the `Int` value is replaced in the definition.\n\n    type alias Qux a =\n        { foo : a }\n\n    Qux a --> TypeAlias { modulePath = [], name = \"Qux\" } [ \"a\" ] [( \"foo\", GenericType \"a\" Nothing )]\n    Qux Int --> TypeAliasRecord { modulePath = [], name = \"Qux\" } [ \"a\" ] [( \"foo\", GenericType \"a\" (Just (Opaque { modulePath = [\"Basics\"], name = \"Int\" } [] )))]\n\n","args":[],"cases":[["GenericType",["String.String","Maybe.Maybe ResolvedType.ResolvedType"]],["Opaque",["ResolvedType.Reference","List.List ResolvedType.ResolvedType"]],["Function",["List.List ResolvedType.ResolvedType","ResolvedType.ResolvedType"]],["TypeAlias",["ResolvedType.Reference","List.List String.String","ResolvedType.ResolvedType"]],["AnonymousRecord",["Maybe.Maybe String.String","List.List ( String.String, ResolvedType.ResolvedType )"]],["CustomType",["ResolvedType.Reference","List.List String.String","List.List ( ResolvedType.Reference, List.List ResolvedType.ResolvedType )"]],["Tuple",["List.List ResolvedType.ResolvedType"]]]}],"aliases":[{"name":"Reference","comment":" Represents a fully qualified name in Elm source code.\n","args":[],"type":"{ modulePath : List.List String.String, name : String.String }"}],"values":[],"binops":[]},{"name":"TypePattern","comment":"\n\n@docs TypePattern\n\n","unions":[{"name":"TypePattern","comment":" A type pattern represents a query over a type annotation. We use these to identify objects of interest in the users code, namely:\n\n1.  Definitions with `Debug.todo` that we want to turn into code.\n2.  Definitions that provide functionality that generated code might want to hook into.\n\nHowever, patterns can also be run in reverse, i.e. these can also be used to generate type annotations for auxiliary defintions.\n\nThe most important constructor here is `Target`, which denotes the type that will drive the code generation process.\n\n","args":[],"cases":[["Target",[]],["Typed",["List.List String.String","String.String","List.List TypePattern.TypePattern"]],["Function",["TypePattern.TypePattern","TypePattern.TypePattern"]],["GenericType",["String.String"]],["Tuple",["List.List TypePattern.TypePattern"]],["Record",["List.List ( String.String, TypePattern.TypePattern )"]]]}],"aliases":[],"values":[],"binops":[]}]